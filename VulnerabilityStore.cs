using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Threading;
using Microsoft.Extensions.Logging;

namespace BWP.Enterprise.Cloud.Vulnerabilities
{
    /// <summary>
    /// Almacén centralizado de vulnerabilidades con caching inteligente
    /// Actúa como fuente única de verdad para información de CVEs
    /// </summary>
    public sealed class VulnerabilityStore : IVulnerabilityStore
    {
        private readonly ILogger<VulnerabilityStore> _logger;
        private readonly ICveIngestionService _cveIngestionService;
        private readonly IVulnerabilityCache _cache;
        private readonly ConcurrentDictionary<string, SoftwareVulnerabilityInfo> _softwareCache;
        private readonly ConcurrentDictionary<string, CveEntry> _cveCache;
        private readonly ConcurrentDictionary<string, DateTime> _lastUpdateTimestamps;
        private readonly Timer _cleanupTimer;
        private readonly SemaphoreSlim _updateLock;
        
        private const int CACHE_EXPIRY_HOURS = 24;
        private const int MAX_CACHE_SIZE = 10000;
        private const int CLEANUP_INTERVAL_MINUTES = 30;
        
        public VulnerabilityStore(
            ILogger<VulnerabilityStore> logger,
            ICveIngestionService cveIngestionService,
            IVulnerabilityCache cache = null)
        {
            _logger = logger;
            _cveIngestionService = cveIngestionService;
            _cache = cache ?? new InMemoryVulnerabilityCache();
            _softwareCache = new ConcurrentDictionary<string, SoftwareVulnerabilityInfo>();
            _cveCache = new ConcurrentDictionary<string, CveEntry>();
            _lastUpdateTimestamps = new ConcurrentDictionary<string, DateTime>();
            _updateLock = new SemaphoreSlim(1, 1);
            
            // Iniciar timer de limpieza
            _cleanupTimer = new Timer(CleanupOldCache, null, 
                TimeSpan.FromMinutes(CLEANUP_INTERVAL_MINUTES), 
                TimeSpan.FromMinutes(CLEANUP_INTERVAL_MINUTES));
            
            _logger.LogInformation("VulnerabilityStore inicializado");
        }
        
        /// <summary>
        /// Verifica si un software específico es vulnerable
        /// </summary>
        public async Task<VulnerabilityCheckResult> CheckSoftwareVulnerabilityAsync(
            string softwareName, 
            string version,
            CancellationToken cancellationToken = default)
        {
            if (string.IsNullOrWhiteSpace(softwareName))
                throw new ArgumentException("Software name is required", nameof(softwareName));
            
            var cacheKey = GenerateCacheKey(softwareName, version);
            
            try
            {
                // 1. Verificar cache rápido
                var cachedResult = await GetFromCacheAsync(cacheKey);
                if (cachedResult != null)
                {
                    _logger.LogDebug("Resultado obtenido de cache para {Software}:{Version}", 
                        softwareName, version);
                    return cachedResult;
                }
                
                // 2. Determinar si necesita actualización
                var needsUpdate = await NeedsUpdateAsync(cacheKey);
                
                if (!needsUpdate)
                {
                    // Intentar obtener del cache persistente
                    var persistentResult = await _cache.GetSoftwareVulnerabilityAsync(softwareName, version);
                    if (persistentResult != null)
                    {
                        await UpdateCacheAsync(cacheKey, persistentResult);
                        return persistentResult;
                    }
                }
                
                // 3. Consultar servicio de ingesta
                await _updateLock.WaitAsync(cancellationToken);
                try
                {
                    // Doble verificación después de adquirir lock
                    cachedResult = await GetFromCacheAsync(cacheKey);
                    if (cachedResult != null)
                    {
                        return cachedResult;
                    }
                    
                    var cves = await _cveIngestionService.GetCvesForSoftwareAsync(
                        softwareName, version, cancellationToken);
                    
                    var result = CreateVulnerabilityResult(softwareName, version, cves);
                    
                    // 4. Actualizar cache
                    await UpdateCacheAsync(cacheKey, result);
                    await _cache.SetSoftwareVulnerabilityAsync(softwareName, version, result);
                    
                    UpdateTimestamp(cacheKey);
                    
                    _logger.LogInformation("Verificada vulnerabilidad para {Software}:{Version} - {Count} CVEs encontrados", 
                        softwareName, version, cves.Count);
                    
                    return result;
                }
                finally
                {
                    _updateLock.Release();
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error verificando vulnerabilidad para {Software}:{Version}", 
                    softwareName, version);
                
                // Retornar resultado seguro en caso de error
                return new VulnerabilityCheckResult
                {
                    SoftwareName = softwareName,
                    SoftwareVersion = version,
                    IsVulnerable = false,
                    CheckTimestamp = DateTime.UtcNow,
                    Error = ex.Message,
                    Status = CheckStatus.Error
                };
            }
        }
        
        /// <summary>
        /// Verifica múltiples software simultáneamente
        /// </summary>
        public async Task<List<VulnerabilityCheckResult>> BatchCheckVulnerabilitiesAsync(
            List<InstalledSoftware> softwareList,
            CancellationToken cancellationToken = default)
        {
            if (softwareList == null || softwareList.Count == 0)
                return new List<VulnerabilityCheckResult>();
            
            var tasks = softwareList.Select(software =>
                CheckSoftwareVulnerabilityAsync(software.Name, software.Version, cancellationToken));
            
            var results = await Task.WhenAll(tasks);
            
            return results.ToList();
        }
        
        /// <summary>
        /// Obtiene CVEs específicos para todo el software instalado
        /// </summary>
        public async Task<SoftwareVulnerabilityReport> GetVulnerabilityReportAsync(
            List<InstalledSoftware> softwareList,
            CancellationToken cancellationToken = default)
        {
            var results = await BatchCheckVulnerabilitiesAsync(softwareList, cancellationToken);
            
            var report = new SoftwareVulnerabilityReport
            {
                GeneratedAt = DateTime.UtcNow,
                TotalSoftwareChecked = softwareList.Count,
                VulnerableSoftwareCount = results.Count(r => r.IsVulnerable),
                Results = results
            };
            
            // Calcular métricas de riesgo
            report.RiskMetrics = CalculateRiskMetrics(results);
            
            _logger.LogInformation("Reporte de vulnerabilidad generado: {Vulnerable}/{Total} software vulnerable", 
                report.VulnerableSoftwareCount, report.TotalSoftwareChecked);
            
            return report;
        }
        
        /// <summary>
        /// Verifica vulnerabilidades críticas que requieren acción inmediata
        /// </summary>
        public async Task<List<CriticalVulnerability>> GetCriticalVulnerabilitiesAsync(
            List<InstalledSoftware> softwareList,
            CancellationToken cancellationToken = default)
        {
            var results = await BatchCheckVulnerabilitiesAsync(softwareList, cancellationToken);
            
            var criticalVulns = new List<CriticalVulnerability>();
            
            foreach (var result in results.Where(r => r.IsVulnerable))
            {
                foreach (var cve in result.Vulnerabilities.Where(v => 
                    v.Severity == "CRITICAL" || v.Severity == "HIGH"))
                {
                    criticalVulns.Add(new CriticalVulnerability
                    {
                        CveId = cve.Id,
                        SoftwareName = result.SoftwareName,
                        SoftwareVersion = result.SoftwareVersion,
                        Severity = cve.Severity,
                        CvssScore = cve.CvssMetrics?.Max(m => m.BaseScore) ?? 0,
                        Description = cve.Description,
                        PublishedDate = cve.Published,
                        ExploitedInWild = CheckIfExploited(cve),
                        PatchAvailable = CheckIfPatchAvailable(cve)
                    });
                }
            }
            
            return criticalVulns
                .OrderByDescending(v => v.CvssScore)
                .ThenByDescending(v => v.Severity)
                .ToList();
        }
        
        /// <summary>
        /// Actualiza el cache para un software específico
        /// </summary>
        public async Task<bool> UpdateSoftwareCacheAsync(
            string softwareName, 
            string version,
            CancellationToken cancellationToken = default)
        {
            var cacheKey = GenerateCacheKey(softwareName, version);
            
            try
            {
                await _updateLock.WaitAsync(cancellationToken);
                
                try
                {
                    // Forzar actualización eliminando cache existente
                    _softwareCache.TryRemove(cacheKey, out _);
                    _lastUpdateTimestamps.TryRemove(cacheKey, out _);
                    
                    // Consultar nuevo
                    var result = await CheckSoftwareVulnerabilityAsync(
                        softwareName, version, cancellationToken);
                    
                    return result.Status == CheckStatus.Success;
                }
                finally
                {
                    _updateLock.Release();
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error actualizando cache para {Software}:{Version}", 
                    softwareName, version);
                return false;
            }
        }
        
        /// <summary>
        /// Actualiza todo el cache del store
        /// </summary>
        public async Task<bool> RefreshAllCacheAsync(CancellationToken cancellationToken = default)
        {
            try
            {
                _logger.LogInformation("Iniciando actualización completa del cache de vulnerabilidades");
                
                // 1. Actualizar cache de CVEs
                var updateSuccess = await _cveIngestionService.RefreshCacheAsync(cancellationToken);
                if (!updateSuccess)
                {
                    _logger.LogWarning("Falló la actualización del cache de CVEs");
                }
                
                // 2. Limpiar cache en memoria
                _softwareCache.Clear();
                _cveCache.Clear();
                
                // 3. Recargar software común
                await ReloadCommonSoftwareAsync(cancellationToken);
                
                _logger.LogInformation("Cache de vulnerabilidades actualizado completamente");
                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error actualizando todo el cache");
                return false;
            }
        }
        
        /// <summary>
        /// Obtiene detalles específicos de un CVE
        /// </summary>
        public async Task<CveEntry> GetCveDetailsAsync(
            string cveId,
            CancellationToken cancellationToken = default)
        {
            if (string.IsNullOrWhiteSpace(cveId))
                throw new ArgumentException("CVE ID is required", nameof(cveId));
            
            // Verificar cache primero
            if (_cveCache.TryGetValue(cveId, out var cachedCve))
            {
                return cachedCve;
            }
            
            try
            {
                var cveDetails = await _cveIngestionService.GetCveDetailsAsync(cveId, cancellationToken);
                
                // Actualizar cache
                _cveCache[cveId] = cveDetails;
                
                return cveDetails;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error obteniendo detalles de CVE: {CveId}", cveId);
                throw;
            }
        }
        
        /// <summary>
        /// Busca vulnerabilidades por criterios específicos
        /// </summary>
        public async Task<List<CveEntry>> SearchVulnerabilitiesAsync(
            VulnerabilitySearchCriteria criteria,
            CancellationToken cancellationToken = default)
        {
            if (criteria == null)
                throw new ArgumentNullException(nameof(criteria));
            
            try
            {
                var results = new List<CveEntry>();
                
                // Búsqueda por software
                if (!string.IsNullOrEmpty(criteria.SoftwareName))
                {
                    var cves = await _cveIngestionService.GetCvesForSoftwareAsync(
                        criteria.SoftwareName, criteria.SoftwareVersion, cancellationToken);
                    
                    results.AddRange(cves);
                }
                
                // Búsqueda por CPE
                else if (!string.IsNullOrEmpty(criteria.CpeString))
                {
                    var cves = await _cveIngestionService.SearchCvesByCpeAsync(
                        criteria.CpeString, cancellationToken);
                    
                    results.AddRange(cves);
                }
                
                // Búsqueda por severidad
                if (!string.IsNullOrEmpty(criteria.Severity))
                {
                    results = results.Where(c => 
                        c.Severity?.Equals(criteria.Severity, StringComparison.OrdinalIgnoreCase) == true)
                        .ToList();
                }
                
                // Búsqueda por fecha
                if (criteria.PublishedAfter.HasValue)
                {
                    results = results.Where(c => c.Published >= criteria.PublishedAfter.Value)
                        .ToList();
                }
                
                if (criteria.PublishedBefore.HasValue)
                {
                    results = results.Where(c => c.Published <= criteria.PublishedBefore.Value)
                        .ToList();
                }
                
                // Ordenar resultados
                results = results
                    .OrderByDescending(c => GetCvssScore(c))
                    .ThenByDescending(c => c.Published)
                    .Take(criteria.MaxResults ?? 100)
                    .ToList();
                
                return results;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error buscando vulnerabilidades");
                throw;
            }
        }
        
        /// <summary>
        /// Obtiene estadísticas del store
        /// </summary>
        public VulnerabilityStoreStats GetStats()
        {
            return new VulnerabilityStoreStats
            {
                Timestamp = DateTime.UtcNow,
                SoftwareCacheCount = _softwareCache.Count,
                CveCacheCount = _cveCache.Count,
                LastUpdateTimestampsCount = _lastUpdateTimestamps.Count,
                MemoryUsageMB = CalculateMemoryUsage(),
                CacheHitRate = CalculateCacheHitRate()
            };
        }
        
        #region Métodos privados
        
        private async Task<VulnerabilityCheckResult> GetFromCacheAsync(string cacheKey)
        {
            if (_softwareCache.TryGetValue(cacheKey, out var cachedInfo))
            {
                // Verificar si el cache está expirado
                if (cachedInfo.LastUpdated > DateTime.UtcNow.AddHours(-CACHE_EXPIRY_HOURS))
                {
                    return cachedInfo.Result;
                }
            }
            
            return null;
        }
        
        private async Task UpdateCacheAsync(string cacheKey, VulnerabilityCheckResult result)
        {
            var info = new SoftwareVulnerabilityInfo
            {
                CacheKey = cacheKey,
                Result = result,
                LastUpdated = DateTime.UtcNow,
                AccessCount = 0
            };
            
            _softwareCache[cacheKey] = info;
            
            // Limitar tamaño del cache
            if (_softwareCache.Count > MAX_CACHE_SIZE)
            {
                var oldest = _softwareCache.Values
                    .OrderBy(v => v.LastUpdated)
                    .FirstOrDefault();
                
                if (oldest != null)
                {
                    _softwareCache.TryRemove(oldest.CacheKey, out _);
                }
            }
        }
        
        private async Task<bool> NeedsUpdateAsync(string cacheKey)
        {
            if (_lastUpdateTimestamps.TryGetValue(cacheKey, out var lastUpdate))
            {
                var timeSinceUpdate = DateTime.UtcNow - lastUpdate;
                return timeSinceUpdate.TotalHours >= CACHE_EXPIRY_HOURS;
            }
            
            return true; // Nunca actualizado, necesita update
        }
        
        private void UpdateTimestamp(string cacheKey)
        {
            _lastUpdateTimestamps[cacheKey] = DateTime.UtcNow;
        }
        
        private VulnerabilityCheckResult CreateVulnerabilityResult(
            string softwareName, 
            string version, 
            List<CveEntry> cves)
        {
            var result = new VulnerabilityCheckResult
            {
                SoftwareName = softwareName,
                SoftwareVersion = version,
                CheckTimestamp = DateTime.UtcNow,
                Vulnerabilities = cves,
                IsVulnerable = cves.Count > 0,
                Status = CheckStatus.Success
            };
            
            // Calcular métricas
            if (cves.Count > 0)
            {
                result.CriticalCount = cves.Count(c => c.Severity == "CRITICAL");
                result.HighCount = cves.Count(c => c.Severity == "HIGH");
                result.MediumCount = cves.Count(c => c.Severity == "MEDIUM");
                result.LowCount = cves.Count(c => c.Severity == "LOW");
                
                result.MaxCvssScore = cves.Max(c => GetCvssScore(c));
                result.AverageCvssScore = cves.Average(c => GetCvssScore(c));
                
                result.ExploitedCount = cves.Count(c => CheckIfExploited(c));
                result.PatchAvailableCount = cves.Count(c => CheckIfPatchAvailable(c));
                
                result.RiskLevel = CalculateRiskLevel(
                    result.CriticalCount, 
                    result.HighCount, 
                    result.MaxCvssScore);
            }
            
            return result;
        }
        
        private double GetCvssScore(CveEntry cve)
        {
            return cve.CvssMetrics?.Max(m => m.BaseScore) ?? 0;
        }
        
        private bool CheckIfExploited(CveEntry cve)
        {
            // Verificar referencias para indicios de explotación
            if (cve.References != null)
            {
                return cve.References.Any(r => 
                    r.Tags?.Contains("Exploit") == true ||
                    r.Url.Contains("exploit", StringComparison.OrdinalIgnoreCase) ||
                    r.Source?.Contains("Metasploit") == true ||
                    r.Source?.Contains("ExploitDB") == true);
            }
            
            return false;
        }
        
        private bool CheckIfPatchAvailable(CveEntry cve)
        {
            // Verificar si hay referencias a parches
            if (cve.References != null)
            {
                return cve.References.Any(r => 
                    r.Tags?.Contains("Patch") == true ||
                    r.Url.Contains("patch", StringComparison.OrdinalIgnoreCase) ||
                    r.Source?.Contains("Microsoft") == true ||
                    r.Source?.Contains("Patch") == true);
            }
            
            return false;
        }
        
        private string CalculateRiskLevel(int criticalCount, int highCount, double maxCvssScore)
        {
            if (criticalCount > 0 || maxCvssScore >= 9.0)
                return "CRITICAL";
            
            if (highCount > 0 || maxCvssScore >= 7.0)
                return "HIGH";
            
            if (maxCvssScore >= 4.0)
                return "MEDIUM";
            
            return "LOW";
        }
        
        private RiskMetrics CalculateRiskMetrics(List<VulnerabilityCheckResult> results)
        {
            var vulnerableResults = results.Where(r => r.IsVulnerable).ToList();
            
            return new RiskMetrics
            {
                TotalVulnerabilities = vulnerableResults.Sum(r => r.Vulnerabilities?.Count ?? 0),
                CriticalVulnerabilities = vulnerableResults.Sum(r => r.CriticalCount),
                HighVulnerabilities = vulnerableResults.Sum(r => r.HighCount),
                MediumVulnerabilities = vulnerableResults.Sum(r => r.MediumCount),
                LowVulnerabilities = vulnerableResults.Sum(r => r.LowCount),
                MaxCvssScore = vulnerableResults.Max(r => r.MaxCvssScore),
                AverageCvssScore = vulnerableResults.Average(r => r.AverageCvssScore),
                ExploitedVulnerabilities = vulnerableResults.Sum(r => r.ExploitedCount),
                PatchedVulnerabilities = vulnerableResults.Sum(r => r.PatchAvailableCount),
                RiskScore = CalculateOverallRiskScore(vulnerableResults)
            };
        }
        
        private double CalculateOverallRiskScore(List<VulnerabilityCheckResult> vulnerableResults)
        {
            if (!vulnerableResults.Any())
                return 0;
            
            double score = 0;
            
            foreach (var result in vulnerableResults)
            {
                var weight = result.RiskLevel switch
                {
                    "CRITICAL" => 1.0,
                    "HIGH" => 0.7,
                    "MEDIUM" => 0.4,
                    "LOW" => 0.1,
                    _ => 0
                };
                
                score += weight * (result.Vulnerabilities?.Count ?? 0);
            }
            
            // Normalizar a escala 0-100
            return Math.Min(100, score * 10);
        }
        
        private async Task ReloadCommonSoftwareAsync(CancellationToken cancellationToken)
        {
            var commonSoftware = new[]
            {
                new { Name = "windows", Version = "10" },
                new { Name = "windows", Version = "11" },
                new { Name = "office", Version = "2019" },
                new { Name = "office", Version = "2021" },
                new { Name = "chrome", Version = "" },
                new { Name = "firefox", Version = "" },
                new { Name = "java", Version = "" }
            };
            
            foreach (var software in commonSoftware)
            {
                try
                {
                    await CheckSoftwareVulnerabilityAsync(
                        software.Name, software.Version, cancellationToken);
                    
                    await Task.Delay(100, cancellationToken); // Respetar rate limits
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Error recargando software común: {Software}", software.Name);
                }
            }
        }
        
        private string GenerateCacheKey(string softwareName, string version)
        {
            return $"{softwareName.ToLowerInvariant()}:{version?.ToLowerInvariant() ?? "any"}";
        }
        
        private void CleanupOldCache(object state)
        {
            try
            {
                var cutoff = DateTime.UtcNow.AddHours(-CACHE_EXPIRY_HOURS * 2);
                
                // Limpiar software cache
                var oldSoftwareKeys = _softwareCache
                    .Where(kv => kv.Value.LastUpdated < cutoff)
                    .Select(kv => kv.Key)
                    .ToList();
                
                foreach (var key in oldSoftwareKeys)
                {
                    _softwareCache.TryRemove(key, out _);
                }
                
                // Limpiar CVE cache
                // Mantener CVEs importantes por más tiempo
                
                // Limpiar timestamps
                var oldTimestampKeys = _lastUpdateTimestamps
                    .Where(kv => kv.Value < cutoff)
                    .Select(kv => kv.Key)
                    .ToList();
                
                foreach (var key in oldTimestampKeys)
                {
                    _lastUpdateTimestamps.TryRemove(key, out _);
                }
                
                _logger.LogDebug("Cache limpiado: {Count} entradas removidas", 
                    oldSoftwareKeys.Count + oldTimestampKeys.Count);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error limpiando cache");
            }
        }
        
        private double CalculateMemoryUsage()
        {
            // Estimación simple
            var totalEntries = _softwareCache.Count + _cveCache.Count;
            return totalEntries * 0.05; // ~50KB por entrada
        }
        
        private double CalculateCacheHitRate()
        {
            // En producción, implementar contadores reales
            return 0.85; // 85% de hit rate estimado
        }
        
        #endregion
    }
    
    #region Modelos de datos
    
    public interface IVulnerabilityStore
    {
        Task<VulnerabilityCheckResult> CheckSoftwareVulnerabilityAsync(
            string softwareName, string version, CancellationToken cancellationToken = default);
        Task<List<VulnerabilityCheckResult>> BatchCheckVulnerabilitiesAsync(
            List<InstalledSoftware> softwareList, CancellationToken cancellationToken = default);
        Task<SoftwareVulnerabilityReport> GetVulnerabilityReportAsync(
            List<InstalledSoftware> softwareList, CancellationToken cancellationToken = default);
        Task<List<CriticalVulnerability>> GetCriticalVulnerabilitiesAsync(
            List<InstalledSoftware> softwareList, CancellationToken cancellationToken = default);
        Task<bool> UpdateSoftwareCacheAsync(string softwareName, string version, CancellationToken cancellationToken = default);
        Task<bool> RefreshAllCacheAsync(CancellationToken cancellationToken = default);
        Task<CveEntry> GetCveDetailsAsync(string cveId, CancellationToken cancellationToken = default);
        Task<List<CveEntry>> SearchVulnerabilitiesAsync(
            VulnerabilitySearchCriteria criteria, CancellationToken cancellationToken = default);
        VulnerabilityStoreStats GetStats();
    }
    
    public class VulnerabilityCheckResult
    {
        public string SoftwareName { get; set; }
        public string SoftwareVersion { get; set; }
        public DateTime CheckTimestamp { get; set; }
        public bool IsVulnerable { get; set; }
        public string RiskLevel { get; set; } // CRITICAL, HIGH, MEDIUM, LOW
        public List<CveEntry> Vulnerabilities { get; set; }
        public int CriticalCount { get; set; }
        public int HighCount { get; set; }
        public int MediumCount { get; set; }
        public int LowCount { get; set; }
        public double MaxCvssScore { get; set; }
        public double AverageCvssScore { get; set; }
        public int ExploitedCount { get; set; }
        public int PatchAvailableCount { get; set; }
        public CheckStatus Status { get; set; }
        public string Error { get; set; }
        
        public VulnerabilityCheckResult()
        {
            Vulnerabilities = new List<CveEntry>();
        }
    }
    
    public enum CheckStatus
    {
        Success,
        Error,
        CacheHit,
        Skipped
    }
    
    public class InstalledSoftware
    {
        public string Name { get; set; }
        public string Version { get; set; }
        public string Vendor { get; set; }
        public DateTime InstallDate { get; set; }
        public string InstallPath { get; set; }
        public bool IsSystemSoftware { get; set; }
    }
    
    public class SoftwareVulnerabilityReport
    {
        public DateTime GeneratedAt { get; set; }
        public int TotalSoftwareChecked { get; set; }
        public int VulnerableSoftwareCount { get; set; }
        public RiskMetrics RiskMetrics { get; set; }
        public List<VulnerabilityCheckResult> Results { get; set; }
        public List<string> Recommendations { get; set; }
        
        public SoftwareVulnerabilityReport()
        {
            Results = new List<VulnerabilityCheckResult>();
            Recommendations = new List<string>();
        }
    }
    
    public class RiskMetrics
    {
        public int TotalVulnerabilities { get; set; }
        public int CriticalVulnerabilities { get; set; }
        public int HighVulnerabilities { get; set; }
        public int MediumVulnerabilities { get; set; }
        public int LowVulnerabilities { get; set; }
        public double MaxCvssScore { get; set; }
        public double AverageCvssScore { get; set; }
        public int ExploitedVulnerabilities { get; set; }
        public int PatchedVulnerabilities { get; set; }
        public double RiskScore { get; set; } // 0-100
    }
    
    public class CriticalVulnerability
    {
        public string CveId { get; set; }
        public string SoftwareName { get; set; }
        public string SoftwareVersion { get; set; }
        public string Severity { get; set; }
        public double CvssScore { get; set; }
        public string Description { get; set; }
        public DateTime PublishedDate { get; set; }
        public bool ExploitedInWild { get; set; }
        public bool PatchAvailable { get; set; }
        public List<string> MitigationSteps { get; set; }
        
        public CriticalVulnerability()
        {
            MitigationSteps = new List<string>();
        }
    }
    
    public class VulnerabilitySearchCriteria
    {
        public string SoftwareName { get; set; }
        public string SoftwareVersion { get; set; }
        public string CpeString { get; set; }
        public string Severity { get; set; }
        public DateTime? PublishedAfter { get; set; }
        public DateTime? PublishedBefore { get; set; }
        public int? MaxResults { get; set; }
        public bool IncludeExploitedOnly { get; set; }
    }
    
    public class VulnerabilityStoreStats
    {
        public DateTime Timestamp { get; set; }
        public int SoftwareCacheCount { get; set; }
        public int CveCacheCount { get; set; }
        public int LastUpdateTimestampsCount { get; set; }
        public double MemoryUsageMB { get; set; }
        public double CacheHitRate { get; set; }
    }
    
    internal class SoftwareVulnerabilityInfo
    {
        public string CacheKey { get; set; }
        public VulnerabilityCheckResult Result { get; set; }
        public DateTime LastUpdated { get; set; }
        public int AccessCount { get; set; }
    }
    
    public interface IVulnerabilityCache
    {
        Task<VulnerabilityCheckResult> GetSoftwareVulnerabilityAsync(string softwareName, string version);
        Task SetSoftwareVulnerabilityAsync(string softwareName, string version, VulnerabilityCheckResult result);
        Task<List<CveEntry>> GetCvesAsync(string cacheKey);
        Task SetCvesAsync(string cacheKey, List<CveEntry> cves);
    }
    
    public class InMemoryVulnerabilityCache : IVulnerabilityCache
    {
        private readonly ConcurrentDictionary<string, VulnerabilityCheckResult> _softwareCache;
        private readonly ConcurrentDictionary<string, List<CveEntry>> _cvesCache;
        
        public InMemoryVulnerabilityCache()
        {
            _softwareCache = new ConcurrentDictionary<string, VulnerabilityCheckResult>();
            _cvesCache = new ConcurrentDictionary<string, List<CveEntry>>();
        }
        
        public Task<VulnerabilityCheckResult> GetSoftwareVulnerabilityAsync(string softwareName, string version)
        {
            var key = $"{softwareName}:{version}";
            _softwareCache.TryGetValue(key, out var result);
            return Task.FromResult(result);
        }
        
        public Task SetSoftwareVulnerabilityAsync(string softwareName, string version, VulnerabilityCheckResult result)
        {
            var key = $"{softwareName}:{version}";
            _softwareCache[key] = result;
            return Task.CompletedTask;
        }
        
        public Task<List<CveEntry>> GetCvesAsync(string cacheKey)
        {
            _cvesCache.TryGetValue(cacheKey, out var cves);
            return Task.FromResult(cves);
        }
        
        public Task SetCvesAsync(string cacheKey, List<CveEntry> cves)
        {
            _cvesCache[cacheKey] = cves;
            return Task.CompletedTask;
        }
    }
    
    #endregion
}